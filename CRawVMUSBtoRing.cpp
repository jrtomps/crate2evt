#include <CRawVMUSBtoRing.h>
#include <CRingBuffer.h>
#include <CRingItem.h>
#include <CRingScalerItem.h>
#include <CPhysicsEventItem.h>
#include <CRingPhysicsEventCountItem.h>
#include <ErrnoException.h>
#include <iostream>
#include <cstring>
#include <memory>
#include <dlfcn.h>

using namespace std;

static const int VMUSBLastBuffer(0x8000);
static const int VMUSBisScaler(0x4000);
static const int VMUSBContinuous(0x2000);
// static const int VMUSBMultiBuffer(0x1000); /* This bit does not exist. */
static const int VMUSBNEventMask(0x1fff);

static const int VMUSBContinuation(0x1000);   /* This bit is in event headers */
static const int VMUSBEventLengthMask(0x0fff);
static const int VMUSBStackIdMask(0xe000);
static const int VMUSBStackIdShift(13);

static const unsigned ReadoutStack(0);
static const unsigned ScalerStack(1);
static const unsigned MonitorStack(7);

static const unsigned BUFFERS_BETWEEN_EVENTCOUNTS(64);  // max buffers before an event count item.

using namespace DAQ::Buffer;

CRawVMUSBtoRing::CRawVMUSBtoRing(CRingBuffer* pBuffer)
  : m_nOutputBufferSize(8192),
  m_pRing(pBuffer),
  m_scalerPeriod(1),
  m_pSclrTimestampExtractor(nullptr),
  m_pEvtTimestampExtractor(nullptr)
{
}

/*
   Process a buffer from the reader.  At this time we are just going
   to figure out what type of buffer we have and dispatch accordingly.
   Buffers are as follows:

  -  Begin run is indicated by the type in the DataBuffer, all others look like
      data buffers.
  -  End run is indicated by the data buffer type.
  - All others are depend on the stack from which they came, and are handled
    by processEvent.

  @note begin and end buffers are generated by software not the VM-USB.

  @param buffer  - The buffer from the readout thread.
*/
void
CRawVMUSBtoRing::processBuffer(ByteBuffer& buffer)
{
  processEvents(buffer);
}

/**!
* Check whether the bit in the global mode register to output
* a second buffer header word is set. 
*
* \return whether the devices is set to out an extra buffer header
*/
bool CRawVMUSBtoRing::hasOptionalHeader()
{
  return m_optionalHeaderExists;
}


/**
 * Process events in a buffer creating output buffers as required.
 *  - Figure out the used words in the buffer
 *  - For each event in the buffer invoke either event or scaler depending on
 *    the stack number.  Stack 1 is always a scaler event while any other stack
 *    is considered a physics event.
 *  - Stack 7 is the monitor stack and is sent to the Tcl server via a Tcl event
 *    sent to its event queue.
 *
 * @param inBuffer  -  Reference to a raw input buffer.
 */
void 
CRawVMUSBtoRing::processEvents(ByteBuffer& inBuffer)
{
  Deserializer<ByteBuffer> buffer(inBuffer);

  uint16_t bufferHeader;
  buffer >> bufferHeader;

  int16_t  nEvents    = bufferHeader & VMUSBNEventMask;
  bool isScalerBuffer = ((0x4000&bufferHeader)==0x4000);
//  cout << "Header  : " << hex << bufferHeader << dec << endl;
//  cout << "nEvents : " << hex << nEvents << dec << endl;

  ssize_t  nWords    = inBuffer.size()/sizeof(uint16_t) - 2; // Remaining words read.

  // Check if the optional second header exists
  if (hasOptionalHeader()) {
    validateOptionalHeader(buffer, nWords);
  } 

  int16_t nTotalEvents = nEvents;
  while (nEvents>0 && !buffer.eof()) {

    // Pull the event length and stack number from the header:
    // event length is not self inclusive and is in uint16_t units.

    uint16_t header = buffer.peek<uint16_t>();
    size_t   eventLength = header & VMUSBEventLengthMask;
    uint8_t  stackNum   = (header & VMUSBStackIdMask) >> VMUSBStackIdShift;
//    cout << "\nEvent # : " << nTotalEvents-nEvents 
//         << " @ " << std::distance(buffer.begin(), buffer.pos()) << endl;

    if (isScalerBuffer) {
      scaler(buffer);
    }
    else {
      event(buffer);
    }

    nEvents--;
  } // end processing loop

  // CLEANUP WORK
  //
  if ( buffer.eof() ) {
    cout << "NO EOB found!" << endl;
  } else {
    validateEndOfBuffer(buffer);
  }
  // I've seen the VM-USB hand me a bogus event count...but never a bogus
  // buffer word count.  This is non fatal but reported.
  if (buffer.pos() != buffer.end()) {
    if (buffer.pos() < buffer.end()) {
      cerr << "Warning failed to use up last " 
        << std::distance(buffer.pos(), buffer.end()) << " bytes in buffer" << endl;
      uint16_t value;
      while ((buffer>> value)) {
        cout << "\t\t" << hex << value << dec << endl;
      }
    } else {
      cerr << "Warning used up more than the buffer by " 
        << std::distance(buffer.end(), buffer.pos()) << endl;
    }
  }

  m_nBuffersBeforeEventCount--;
  if (m_nBuffersBeforeEventCount == 0) {

    // No scaler buffers maybe so figure out the time in seconds we are
    // into the run from the realtime clock...forget fractions.

    timespec now;
    clock_gettime(CLOCK_REALTIME, &now);

    outputTriggerCount(now.tv_sec - m_startTimestamp.tv_sec);   // Figure out run offset.
    m_nBuffersBeforeEventCount = BUFFERS_BETWEEN_EVENTCOUNTS;
  }

}

void CRawVMUSBtoRing::validateOptionalHeader(Deserializer<ByteBuffer>& buffer, size_t nWords)
{
    uint16_t wordsInBuffer;  
    buffer >> wordsInBuffer;
    if (wordsInBuffer != nWords) {
      // The words that are reported in the optional header do not count 
      // the first buffer header word. The number is self inclusive though.
      cerr << "VMUSB specifies " << wordsInBuffer << " in buffer, but ";
      cerr << "the number of words read (" << nWords << ") is in disagreement." ;
    }
}

void CRawVMUSBtoRing::validateEndOfBuffer(Deserializer<ByteBuffer>& buffer)
{
  // Next long should be 0xffffffff buffer terminator:
  // I've seen this happen but it's not fatal...just go on to the next buffer.

  //  std::cout << "Checking EOB @ " << distance(buffer.begin(), buffer.pos()) << endl;
  uint32_t nextLong;
  buffer >> nextLong;
  if (nextLong != 0xffffffff) {
    cerr << "Ran out of events but did not see buffer terminator\n";
    cerr << distance(buffer.pos(), buffer.end()) << " bytes remaining unprocessed\n";
    cerr <<  "Observed instead 0x" << hex << nextLong << dec << endl;
  } else {
  //  cout << "FOUND" << endl;
  }
}

/**
 * Output a physics trigger count event item.  These are used to monitor
 * overall rates as well as to provide sampling statistics for sampling
 * consumers.
 *
 * @param runOffset - seconds intothe run at which this is being emitted.
 */
void
CRawVMUSBtoRing::outputTriggerCount(uint32_t runOffset)
{
  CRingPhysicsEventCountItem item(m_nEventsSeen, runOffset);
  item.commitToRing(*m_pRing);
}

/**
 * Process a scaler event:
 * - Figure out the time interval start/stop times, and the absolute time.
 * - extract the vector of scalers from the VM-USB event.
 * - Create and submit the CRingScalerItem to the ring.
 *  
 * @note We assume scaler events won't consist of more than 2048
 *       scalers (e.g. the continuation bit is not set.

 * @param pData - Pointer to scaler data.
 *
 * @throw std::string - If a scaler buffer has a continuation segment.
 * @throw CErrnoException - If we can't get the absolute timestamp.
 * @throw std::string - From CRingBuffer if unable to commit the item to the ring.
 */
void
CRawVMUSBtoRing::scaler(Deserializer<ByteBuffer>& buffer)
{

  cout << "scaler" << endl;

  // Figure out where the scalers are and fetch the event header.

  uint16_t  header;
  buffer >> header;

  // See Issue #424 - for now throw an error  if there's a continuation segment:


  // Figure out how many wods/scalers there are:

  size_t        nWords   =  header & VMUSBEventLengthMask;
  size_t        nScalers =  nWords/(sizeof(uint32_t)/sizeof(uint16_t));

  // Marshall the scalers into an std::vector:

  std::vector<uint32_t> counterData = extractScalerData(buffer, nScalers);

  // The VM-USB does not timestamp scaler data for us at this time so we
  // are going to rely on the scaler period to be correct:

  uint32_t endTime = m_elapsedSeconds + m_scalerPeriod;

  // Output a ring count item using this time:

  outputTriggerCount(endTime);
  m_nBuffersBeforeEventCount = BUFFERS_BETWEEN_EVENTCOUNTS;

  // Create the final scaler item and submit it to the ring.
  formAndOutputScalerItem(buffer, counterData, endTime);

  m_elapsedSeconds = endTime;

}

vector<uint32_t> CRawVMUSBtoRing::extractScalerData(Deserializer<ByteBuffer>& buffer, size_t nScalers)
{
  vector<uint32_t> counters;
  counters.reserve(nScalers);

  for (size_t i = 0; i < nScalers; i++) {
    uint32_t value;
    buffer >> value;
    counters.push_back(value);
  }

  return counters;
}

void CRawVMUSBtoRing::formAndOutputScalerItem(Deserializer<ByteBuffer>& buffer,
                                              const vector<uint32_t>& counterData,
                                              uint32_t endTime)
{

  time_t timestamp;
  if (time(&timestamp) == -1) {
    throw CErrnoException("CRawVMUSBtoRing::scaler unable to get the absolute timestamp");
  }

  unique_ptr<CRingItem> pEvent;
  if (m_pSclrTimestampExtractor) {
    void* pData = const_cast<void*>(
                                    static_cast<const void*>(buffer.getContainer().data()
                                    +std::distance(buffer.begin(),buffer.pos())
                                              )
                  );
    pEvent.reset(new CRingScalerItem(m_pSclrTimestampExtractor(pData), 
                                 m_sourceId,
                                 0,
                                 m_elapsedSeconds, 
                                 endTime, 
                                 timestamp, 
                                 counterData,
				 1, false));
  } else {
    pEvent.reset(new CRingScalerItem(m_elapsedSeconds, 
                                 endTime, 
                                 timestamp, 
                                 counterData,
				 false));
  }

  pEvent->commitToRing(*m_pRing);
}

/**
 * Process a single event:
 * - If necessary create the event assembly buffer and initialize its
 *   cursor.
 * - Put the segment in the event assembly buffer.
 * - If there is a continuation segment we're done for now..as we'll get called again with the next
 *   segment
 * - If there is no continuation segment then we create and submit the output
 *   event to the ring and reset the cursor.
 *
 * @param pData - pointer to a VM-USB event segment.
 *
 * @throws std::string - event overflows the output buffer.
 * @throws std::string - Errors from the ring buffer classes.
 *
 * @note The data go in in native VM-USB format.  That's what the SpecTcl disassembler expects.
 */
void 
CRawVMUSBtoRing::event(Deserializer<ByteBuffer>& buffer)
{
//  cout << "event" << endl;
  // If necessary make an new output buffer

  // Initialize the pointers to event bits and pieces.

  uint16_t  header = buffer.peek<uint16_t>();
//  cout << "\theader : " << hex << header << " (" << dec << header << ")" << endl;
//  cout << "\tpos    : " << std::distance(buffer.begin(), buffer.pos()) << endl;

  size_t shortsInSegment = (header & VMUSBEventLengthMask) + 1;
  
  // allocate more memory if necessary
  size_t bytesInSegment = shortsInSegment*sizeof(uint16_t);
  if ((m_buffer.size() + bytesInSegment)  > m_buffer.capacity()) {
    m_buffer.reserve(m_buffer.size() + 2*bytesInSegment);
  }

  auto endCopy = buffer.pos()+bytesInSegment;
  m_buffer.insert(m_buffer.end(), buffer.pos(), endCopy);
  buffer.setPosition(endCopy);
//  cout << "\t# bytes = " << bytesInSegment << endl;

  if (eventComplete(header)) {			    // Ending segment:

    formAndOutputPhysicsEventItem();
    // Reset the cursor and word count in the assembly buffer:

    m_buffer.clear();
    m_nEventsSeen++;
  }

}

bool CRawVMUSBtoRing::eventComplete(uint16_t header)
{
  return (header & VMUSBContinuation) == 0;
}

void CRawVMUSBtoRing::formAndOutputPhysicsEventItem()
{
    unique_ptr<CRingItem> pEvent;

    if (m_pEvtTimestampExtractor) {
      pEvent.reset(new CRingItem(PHYSICS_EVENT, 
                                 m_pEvtTimestampExtractor(m_buffer.data()), m_sourceId,
                                 0, m_buffer.size() + 100));        
    } else {
      pEvent.reset(new CRingItem(PHYSICS_EVENT, m_buffer.size() + 100)); // +100 really needed?
    }

    CRingItem& event(*pEvent);
    fillBodyWithData(event, m_buffer);
}

void CRawVMUSBtoRing::fillBodyWithData(CRingItem& event, const std::vector<uint8_t>& data)
{
    uint8_t* pDest = reinterpret_cast<uint8_t*>(event.getBodyPointer());
    uint8_t* pEnd = std::copy(data.begin(), data.end(), pDest);

    event.setBodyCursor(pEnd);
    event.updateSize();
    event.commitToRing(*m_pRing);
}

/**
 * getTimestampExtractor
 *    Fills in m_pTimestampExtractor if this should be non-null
 *    - If the Globals::pTimestampExtractor is non-null
 *      it is a path to a shared lib that is mapped.
 *    - If successfully mapped, the entry points getEventTimestamp() and
 *      and getScalerTimestamp() are located
 *    - If that's found the pointer to getEventTimestamp is filled in for
 *      m_pEvtTimestampExtractor and the getScalerTimestamp is filled in for
 *      m_pSclrTimestampExtractor.
 */
void
CRawVMUSBtoRing::getTimestampExtractor()
{
    if (!m_tstampExtractorLib.empty()) {
        void* pDllHandle = dlopen(
            m_tstampExtractorLib.c_str(), RTLD_NOW | RTLD_NODELETE
        );
        // Load the so/dll:
        
        if (!pDllHandle) {
            std::cerr << "Failed to load timestamp extractor library: "
                << m_tstampExtractorLib << " "  << dlerror() << std::endl;
            exit(EXIT_FAILURE);
        }
        // Locate the function entry point:
        
        void* pEvtFunction = dlsym(pDllHandle, "getEventTimestamp");
        if (!pEvtFunction) {
            std::cerr << "Warning: Unable to locate getEventTimestamp  in "
                << m_tstampExtractorLib << " "
                << dlerror() << std::endl;
        } else {
            m_pEvtTimestampExtractor = reinterpret_cast<TimestampExtractor>(pEvtFunction);
        }

        void* pSclrFunction = dlsym(pDllHandle, "getScalerTimestamp");
        if (!pSclrFunction) {
            std::cerr << "Warning: Unable to locate getScalerTimestamp  in "
                << m_tstampExtractorLib << " "
                << dlerror() << std::endl;
        } else {
            m_pSclrTimestampExtractor = reinterpret_cast<TimestampExtractor>(pSclrFunction);
        }

        // save the entry point and close the handle (RTLD_NODELETE) keeps
        // the .so/.dll in  memory:
        if (m_pSclrTimestampExtractor==0 && m_pEvtTimestampExtractor==0) {
            std::cerr << "Fatal error: user provided library with neither"
                      << " timestamp extractor function" << std::endl;
            exit(EXIT_FAILURE);
        }

        dlclose(pDllHandle);
        
    }
}
