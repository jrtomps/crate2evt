#include <CRawVMUSBtoRing.h>
#include <CRingBuffer.h>
#include <CRingItem.h>
#include <CRingScalerItem.h>
#include <CPhysicsEventItem.h>
#include <CRingPhysicsEventCountItem.h>
#include <ErrnoException.h>
#include <iostream>
#include <cstring>
#include <dlfcn.h>

using namespace std;

static const int VMUSBLastBuffer(0x8000);
static const int VMUSBisScaler(0x4000);
static const int VMUSBContinuous(0x2000);
// static const int VMUSBMultiBuffer(0x1000); /* This bit does not exist. */
static const int VMUSBNEventMask(0x1fff);

static const int VMUSBContinuation(0x1000);   /* This bit is in event headers */
static const int VMUSBEventLengthMask(0x0fff);
static const int VMUSBStackIdMask(0xe000);
static const int VMUSBStackIdShift(13);

static const unsigned ReadoutStack(0);
static const unsigned ScalerStack(1);
static const unsigned MonitorStack(7);

static const unsigned BUFFERS_BETWEEN_EVENTCOUNTS(64);  // max buffers before an event count item.


CRawVMUSBtoRing::CRawVMUSBtoRing(CRingBuffer* pBuffer)
  : m_pRing(pBuffer),
  m_scalerPeriod(1),
  m_pSclrTimestampExtractor(nullptr),
  m_pEvtTimestampExtractor(nullptr)
{
}

/*
   Process a buffer from the reader.  At this time we are just going
   to figure out what type of buffer we have and dispatch accordingly.
   Buffers are as follows:

  -  Begin run is indicated by the type in the DataBuffer, all others look like
      data buffers.
  -  End run is indicated by the data buffer type.
  - All others are depend on the stack from which they came, and are handled
    by processEvent.

  @note begin and end buffers are generated by software not the VM-USB.

  @param buffer  - The buffer from the readout thread.
*/
void
CRawVMUSBtoRing::processBuffer(std::vector<IOU16>& buffer)
{
  processEvents(buffer);
}

/**!
* Check whether the bit in the global mode register to output
* a second buffer header word is set. 
*
* \return whether the devices is set to out an extra buffer header
*/
bool CRawVMUSBtoRing::hasOptionalHeader()
{
  return m_optionalHeaderExists;
}


/**
 * Process events in a buffer creating output buffers as required.
 *  - Figure out the used words in the buffer
 *  - For each event in the buffer invoke either event or scaler depending on
 *    the stack number.  Stack 1 is always a scaler event while any other stack
 *    is considered a physics event.
 *  - Stack 7 is the monitor stack and is sent to the Tcl server via a Tcl event
 *    sent to its event queue.
 *
 * @param inBuffer  -  Reference to a raw input buffer.
 */
static uint32_t  bufferNumber = 0; 
  void 
CRawVMUSBtoRing::processEvents(std::vector<IOU16>& inBuffer)
{
  IOU16* pContents = inBuffer.data();
  int16_t  nEvents   = pContents->value & VMUSBNEventMask;
  bool isScalerBuffer = ((0x4000&pContents->value)==0x4000);

  bufferNumber++;

  pContents++;			// Point to first event.
  ssize_t    nWords    = inBuffer.size() - 1; // Remaining words read.

  // Check if the optional second header exists
  if (hasOptionalHeader()) {
    uint16_t wordsInBuffer = pContents->value;  
    ++pContents;
    if (wordsInBuffer != nWords-1) {
      // The words that are reported in the optional header do not count 
      // the first buffer header word. The number is self inclusive though.
      cerr << "VMUSB specifies " << wordsInBuffer << " in buffer, but ";
      cerr << "the number of words read is in disagreement." ;
    }
    --nWords;
  } 

  while (nWords > 0) {
    if (nEvents <= 0) {
      // Next long should be 0xffffffff buffer terminator:
      // I've seen this happen but it's not fatal...just go on to the next buffer.

      uint32_t nextLong = pContents->value;
      nextLong = ((pContents+1)->value << 16);
      if (nextLong != 0xffffffff) {
        cerr << "Ran out of events but did not see buffer terminator\n";
        cerr << nWords << " remaining unprocessed\n";
      }

      break;			// trusting event count vs word count(?).
    }

    // Pull the event length and stack number from the header:
    // event length is not self inclusive and is in uint16_t units.

    uint16_t header     = pContents->value;
    size_t   eventLength = header & VMUSBEventLengthMask;
    uint8_t  stackNum   = (header & VMUSBStackIdMask) >> VMUSBStackIdShift;

    // Dispatch depending on the actual stack number.  The dispatch provided
    // allows for multiple event stacks (e.g. interrupt triggered stacks
    // that do different things).

    if (isScalerBuffer) {
      scaler(pContents);
    }
    else {
      event(pContents);
    }
    // Point at the next event and compute the remaining word and event counts.

    pContents->value += eventLength + 1; // Event count is not self inclusive.
    nWords    -= (eventLength + 1);
    nEvents--;
  }

  // I've seen the VM-USB hand me a bogus event count...but never a bogus
  // buffer word count.  This is non fatal but reported.

  if (nWords < 0) {
    cerr << "Warning used up more than the buffer  by " << (-nWords) << endl;
  }
  m_nBuffersBeforeEventCount--;
  if (m_nBuffersBeforeEventCount == 0) {

    // No scaler buffers maybe so figure out the time in seconds we are
    // into the run from the realtime clock...forget fractions.

    timespec now;
    clock_gettime(CLOCK_REALTIME, &now);

    outputTriggerCount(now.tv_sec - m_startTimestamp.tv_sec);   // Figure out run offset.
    m_nBuffersBeforeEventCount = BUFFERS_BETWEEN_EVENTCOUNTS;
  }
}

/**
 * Output a physics trigger count event item.  These are used to monitor
 * overall rates as well as to provide sampling statistics for sampling
 * consumers.
 *
 * @param runOffset - seconds intothe run at which this is being emitted.
 */
void
CRawVMUSBtoRing::outputTriggerCount(uint32_t runOffset)
{
  CRingPhysicsEventCountItem item(m_nEventsSeen, runOffset);
  item.commitToRing(*m_pRing);
}

/**
 * Process a scaler event:
 * - Figure out the time interval start/stop times, and the absolute time.
 * - extract the vector of scalers from the VM-USB event.
 * - Create and submit the CRingScalerItem to the ring.
 *  
 * @note We assume scaler events won't consist of more than 2048
 *       scalers (e.g. the continuation bit is not set.

 * @param pData - Pointer to scaler data.
 *
 * @throw std::string - If a scaler buffer has a continuation segment.
 * @throw CErrnoException - If we can't get the absolute timestamp.
 * @throw std::string - From CRingBuffer if unable to commit the item to the ring.
 */
void
CRawVMUSBtoRing::scaler(IOU16* pData)
{


  time_t timestamp;
  if (time(&timestamp) == -1) {
    throw CErrnoException("CRawVMUSBtoRing::scaler unable to get the absolute timestamp");
  }

  // Figure out where the scalers are and fetch the event header.

  IOU16* pHeader = pData;
  uint16_t  header  = pHeader->value;
  IOU16* pBody   = pHeader+1; // Pointer to the scalers.

  // See Issue #424 - for now throw an error  if there's a continuation segment:


  // Figure out how many wods/scalers there are:

  size_t        nWords   =  header & VMUSBEventLengthMask;
  size_t        nScalers =  nWords/(sizeof(uint32_t)/sizeof(uint16_t));

  // Marshall the scalers into an std::vector:

  std::vector<uint32_t> counterData;
  for (int i = 0; i < nScalers; i++) {
    uint32_t value = pBody->value;
    pBody++;
    value          += (pBody->value) << 16;
    pBody++;
    counterData.push_back(value);
  }

  // The VM-USB does not timestamp scaler data for us at this time so we
  // are going to rely on the scaler period to be correct:

  uint32_t endTime = m_elapsedSeconds + m_scalerPeriod;

  // Output a ring count item using this time:

  outputTriggerCount(endTime);
  m_nBuffersBeforeEventCount = BUFFERS_BETWEEN_EVENTCOUNTS;

  // Create the final scaler item and submit it to the ring.

  CRingItem* pEvent;
  if (m_pSclrTimestampExtractor) {
    pEvent = new CRingScalerItem(m_pSclrTimestampExtractor(pData), 
                                 m_sourceId,
                                 0,
                                 m_elapsedSeconds, 
                                 endTime, 
                                 timestamp, 
                                 counterData,
				 1, false);
  } else {
    pEvent = new CRingScalerItem(m_elapsedSeconds, 
                                 endTime, 
                                 timestamp, 
                                 counterData,
				 false);
  }

  pEvent->commitToRing(*m_pRing);
  m_elapsedSeconds = endTime;
  delete pEvent;
}



/**
 * Create a new output buffer.
 * for now this is trivial
 *
 * @return uint8_t*
 * @retval Pointer to the output buffer.
 */
uint8_t* 
CRawVMUSBtoRing::newOutputBuffer()
{
  return reinterpret_cast<uint8_t*>(malloc(m_nOutputBufferSize));
  
}
/**
 * Process a single event:
 * - If necessary create the event assembly buffer and initialize its
 *   cursor.
 * - Put the segment in the event assembly buffer.
 * - If there is a continuation segment we're done for now..as we'll get called again with the next
 *   segment
 * - If there is no continuation segment then we create and submit the output
 *   event to the ring and reset the cursor.
 *
 * @param pData - pointer to a VM-USB event segment.
 *
 * @throws std::string - event overflows the output buffer.
 * @throws std::string - Errors from the ring buffer classes.
 *
 * @note The data go in in native VM-USB format.  That's what the SpecTcl disassembler expects.
 */
void 
CRawVMUSBtoRing::event(IOU16* pData)
{
  // If necessary make an new output buffer

  if (!m_pBuffer) {
    m_pBuffer        = newOutputBuffer();
    m_pCursor        = m_pBuffer;
    m_nWordsInBuffer = 0;	  
  }

  // Initialize the pointers to event bits and pieces.

  IOU16* pSegment = pData;
  uint16_t  header   = pSegment->value;

  // Figure out the header:
 
  size_t segmentSize = header & VMUSBEventLengthMask;
  bool   haveMore    = (header & VMUSBContinuation) != 0;
  
  // Events must currently fit in the buffer...otherwise we throw an error.

  segmentSize += 1;		// Size is not self inclusive

  if ((segmentSize + m_nWordsInBuffer) >= m_nOutputBufferSize/sizeof(uint16_t)) {
    int newSize          = 2*segmentSize*sizeof(uint16_t);
    uint8_t* pNewBuffer = reinterpret_cast<uint8_t*>(realloc(m_pBuffer, m_nOutputBufferSize+newSize));
    if (pNewBuffer) {
      m_pBuffer            = pNewBuffer;
      m_pCursor            = m_pBuffer + m_nWordsInBuffer * sizeof(uint16_t);
      m_nOutputBufferSize += newSize;

    } else {
      throw std::string("Failed to resize event buffer to fit an oversized segment");
    }


  }
  // Next we can copy our data to the output buffer and update the cursor
  // remembering that the size is not self inclusive:
  //
  memcpy(m_pCursor, pData, segmentSize*sizeof(uint16_t));
  m_nWordsInBuffer += segmentSize;
  m_pCursor += segmentSize*sizeof(uint16_t); // advance the cursor

  

  // If that was the last segment submit it and reset cursors and counters.

  if (!haveMore) {			    // Ending segment:
    //
    // IF we were given a timestamp extractor we create an event with full
    // body header.
    
    CRingItem* pEvent;
    if (m_pEvtTimestampExtractor) {
        pEvent = new CRingItem(
            PHYSICS_EVENT, m_pEvtTimestampExtractor(m_pBuffer), m_sourceId,
            0, m_nWordsInBuffer*sizeof(uint16_t) + 100
        );        
    } else {
        pEvent = new CRingItem(
            PHYSICS_EVENT, m_nWordsInBuffer*sizeof(uint16_t) + 100
        ); // +100 really needed?
    }

    CRingItem& event(*pEvent);
    // Put the data in the event and figure out where the end pointer is.

    void* pDest = event.getBodyPointer();
    memcpy(pDest, m_pBuffer, m_nWordsInBuffer*sizeof(uint16_t));
    uint8_t* pEnd = reinterpret_cast<uint8_t*>(pDest);
    pEnd += m_nWordsInBuffer*sizeof(uint16_t); // Where the new body cursor goes.

    event.setBodyCursor(pEnd);
    event.updateSize();
    event.commitToRing(*m_pRing);
    delete pEvent;
    // Reset the cursor and word count in the assembly buffer:

    m_nWordsInBuffer = 0;
    m_pCursor        = m_pBuffer;
    
    m_nEventsSeen++;
  }

}
/**
 * getTimestampExtractor
 *    Fills in m_pTimestampExtractor if this should be non-null
 *    - If the Globals::pTimestampExtractor is non-null
 *      it is a path to a shared lib that is mapped.
 *    - If successfully mapped, the entry points getEventTimestamp() and
 *      and getScalerTimestamp() are located
 *    - If that's found the pointer to getEventTimestamp is filled in for
 *      m_pEvtTimestampExtractor and the getScalerTimestamp is filled in for
 *      m_pSclrTimestampExtractor.
 */
void
CRawVMUSBtoRing::getTimestampExtractor()
{
    if (!m_tstampExtractorLib.empty()) {
        void* pDllHandle = dlopen(
            m_tstampExtractorLib.c_str(), RTLD_NOW | RTLD_NODELETE
        );
        // Load the so/dll:
        
        if (!pDllHandle) {
            std::cerr << "Failed to load timestamp extractor library: "
                << m_tstampExtractorLib << " "  << dlerror() << std::endl;
            exit(EXIT_FAILURE);
        }
        // Locate the function entry point:
        
        void* pEvtFunction = dlsym(pDllHandle, "getEventTimestamp");
        if (!pEvtFunction) {
            std::cerr << "Warning: Unable to locate getEventTimestamp  in "
                << m_tstampExtractorLib << " "
                << dlerror() << std::endl;
        } else {
            m_pEvtTimestampExtractor = reinterpret_cast<TimestampExtractor>(pEvtFunction);
        }

        void* pSclrFunction = dlsym(pDllHandle, "getScalerTimestamp");
        if (!pSclrFunction) {
            std::cerr << "Warning: Unable to locate getScalerTimestamp  in "
                << m_tstampExtractorLib << " "
                << dlerror() << std::endl;
        } else {
            m_pSclrTimestampExtractor = reinterpret_cast<TimestampExtractor>(pSclrFunction);
        }

        // save the entry point and close the handle (RTLD_NODELETE) keeps
        // the .so/.dll in  memory:
        if (m_pSclrTimestampExtractor==0 && m_pEvtTimestampExtractor==0) {
            std::cerr << "Fatal error: user provided library with neither"
                      << " timestamp extractor function" << std::endl;
            exit(EXIT_FAILURE);
        }

        dlclose(pDllHandle);
        
    }
}
